-- DAY10

-- DDL 
-- 테이블 무결성 제약조건 (CONSTRAINT)

-- 1. NOT NULL
-- 컬럼에 값이 반드시 기록되어야 할 때 설정함 (웹에서의 필수입력항목을 뜻함)
-- 컬럼 레벨에서만 설정할 수 있음.

CREATE TABLE TESTNN (
    NNID  NUMBER(5)  NOT NULL,  -- 컬럼 레벨
    NN_NAME VARCHAR2(20)
);

-- 값 기록 테스트
INSERT INTO TESTNN (NNID, NN_NAME)
VALUES (NULL, NULL);  -- ERROR
-- NNID 에 NOT NULL 제약조건 위배됨.

INSERT INTO TESTNN -- 컬럼명이 생략되면, 테이블의 모든 컬럼에 값 기록해야 함
VALUES (1, NULL);  -- 테이블의 컬럼 생성 순서와 자료형 맞춰서 값 기록 나열함

SELECT * FROM TESTNN;

INSERT INTO TESTNN (NN_NAME)
VALUES ('ORACLE');  -- 생략된 컬럼은 자동 NULL 처리됨 >> 에러

-- 테이블 레벨 적용 
CREATE TABLE TESTNN2 (
    NN_ID NUMBER(5) CONSTRAINT T2_NNID NOT NULL,
    NN_NAME VARCHAR2(10)--,
    -- 테이블 레벨
    -- [CONSTRAINT 제약조건이름] 제약조건종류 (적용할 컬럼명)
   -- CONSTRAINT T2_NNNAME NOT NULL (NN_NAME)  >> ERROR
);


-- 2. UNIQUE
-- 해당 컬럼의 중복값(같은값) 입력을 막겠다는 의미의 제약조건임
-- 설정하면 같은 값은 두번 기록 못 하는 컬럼이 됨
-- 컬럼레벨, 테이블레벨 둘 다 설정할 수 있음
-- 복합키로도 설정할 수 있음.

CREATE TABLE TESTUN (
    UN_ID  CHAR(3)  UNIQUE,
    UN_NAME VARCHAR2(10) NOT NULL
);

-- 기록 테스트
INSERT INTO TESTUN VALUES ('AAA', 'ORACLE');
INSERT INTO TESTUN VALUES ('AAA', 'JAVA');  -- 제약조건 위배됨 >> 에러
INSERT INTO TESTUN VALUES ('AAB', 'JAVA');

SELECT * FROM TESTUN;

CREATE TABLE TESTUN2 (
    UN_ID  CHAR(3)  CONSTRAINT T2_UNID UNIQUE,
    UN_NAME VARCHAR2(10) CONSTRAINT T2_UNNAME NOT NULL
);

CREATE TABLE TESTUN3 (
    UN_ID  CHAR(3),
    UN_NAME VARCHAR2(10) NOT NULL,
    CONSTRAINT T3_UNID UNIQUE (UN_ID)
);

-- 3. PRIMARY KEY
-- 테이블에서 한 행의 정보를 찾기위해 쓸 수 있는 값이 기록된 컬럼에 적용함.
-- NOT NULL + UNIQUE
-- 한 테이블에 한 번만 사용할 수 있음.

CREATE TABLE TESTPK (
    PK_ID  NUMBER  PRIMARY KEY,
    PK_NAME VARCHAR2(15)  NOT NULL,
    PK_DATE  DATE
);

-- 기록 테스트
INSERT INTO TESTPK VALUES (1, '홍길동', '15/03/12');
INSERT INTO TESTPK VALUES (NULL, '박문수', SYSDATE);  -- 에러 : NOT NULL 제약조건 위배
INSERT INTO TESTPK VALUES (1, '박문수', SYSDATE);  -- 에러 : UNIQUE 제약조건 위배됨
INSERT INTO TESTPK VALUES (2, '박문수', SYSDATE);

SELECT * FROM TESTPK;

-- 테이블당 한 번만 설정할 수 있음
CREATE TABLE TESTPK2 (
    PID  NUMBER  PRIMARY KEY,
    PNAME VARCHAR2(15)  PRIMARY KEY  
);  -- ERROR

-- 컬럼레벨에서 설정
CREATE TABLE TESTPK2 (
    PID NUMBER  CONSTRAINT P2_PID PRIMARY KEY,
    PNAME VARCHAR2(15),
    PDATE  DATE
);

-- 테이블레벨에서 설정
CREATE TABLE TESTPK3 (
    PID NUMBER,
    PNAME VARCHAR2(15),
    PDATE  DATE,
    CONSTRAINT T3_PID PRIMARY KEY (PID)
);

-- 4. CHECK
-- 컬럼에 기록되는 값에 대한 조건 설정을 하는 제약조건임.
-- CHECK (컬럼명 연산자 비교값)
-- 비교값은 고정값이어야 함. 바뀌는 값이면 에러남.

CREATE TABLE TESTCHK (
    C_NAME VARCHAR2(15)  CONSTRAINT TCK_NAME NOT NULL,
    C_PRICE NUMBER(5) CHECK (C_PRICE BETWEEN 1 AND 99999),
    C_LEVEL CHAR(1) CHECK (C_LEVEL IN ('A', 'B', 'C'))
);

INSERT INTO TESTCHK VALUES ('갤럭시 S9', 65000, 'A');
INSERT INTO TESTCHK VALUES ('LG G7', 125000, 'A');  -- ERROR : CHECK 제약조건 위배됨
INSERT INTO TESTCHK VALUES ('LG G7', 0, 'A');  -- ERROR : CHECK 제약조건 위배됨
INSERT INTO TESTCHK VALUES ('LG G7', 65300, 'D');  -- ERROR : CHECK 제약조건 위배됨

SELECT * FROM TESTCHK;

CREATE TABLE TESTCHK2 (
    C_NAME  VARCHAR2(15)  PRIMARY KEY,
    C_PRICE  NUMBER(5)  CHECK (C_PRICE >= 1 AND C_PRICE <= 99999),
    C_LEVEL  CHAR(1)  CHECK (C_LEVEL = 'A' OR C_LEVEL = 'B' OR C_LEVEL = 'C'),
    --C_DATE  DATE  CHECK (C_DATE < SYSDATE)
    -- 비교값은 반드시 리터럴(값) 사용, 바뀌는 값은 사용 못 함
    --C_DATE  DATE  CHECK (C_DATE < TO_DATE('16/01/01', 'RR/MM/DD'))  -- OK
    C_DATE  DATE  CHECK (C_DATE < TO_DATE('16/01/01', 'YYYY/MM/DD'))  -- BUG
);


-- 5. FOREIGN KEY
-- 외래키, 외부키
-- 다른 테이블에서 제공하는 값만 사용할 수 있는 컬럼을 의미함
-- 제공되지 않는 값 사용하면 에러남

-- 컬럼레벨에서 설정
-- [CONSTRAINT 이름] REFERENCES 참조테이블명 [(참조할 컬럼명)]
-- 테이블레벨에서 설정
-- [CONSTRAINT 이름] FOREIGN KEY (적용할 컬럼명) REFERENCES 참조테이블 [(참조컬럼명)]
-- NULL 은 사용할 수 있음

CREATE TABLE TESTFK (
    EMP_ID  CHAR(3) REFERENCES EMPLOYEE,
    -- 참조컬럼명이 생략되면 PRIMARY KEY 컬럼이 자동 연결됨
    DEPT_ID  CHAR(2) CONSTRAINT TFK_DID REFERENCES DEPARTMENT (DEPT_ID),
    JOB_ID  CHAR(2),
    -- 테이블레벨
    CONSTRAINT TFK_JID FOREIGN KEY (JOB_ID) REFERENCES JOB (JOB_ID)
);

-- 기록 테스트
-- 연결된 테이블의 연결된 컬럼에 기록되어 있는 값만 사용할 수 있음.
INSERT INTO TESTFK VALUES ('300', NULL, NULL);  -- 제공되지 않는 값 사용, 에러
INSERT INTO TESTFK VALUES ('100', NULL, NULL);  -- OK
INSERT INTO TESTFK VALUES ('200', '70', NULL);  -- 제공되지 않는 부서코드 사용, 에러
INSERT INTO TESTFK VALUES ('200', '90', NULL);  -- OK
INSERT INTO TESTFK VALUES ('124', '80', 'J9');  -- 제공되지 않는 직급코드 사용, 에러
INSERT INTO TESTFK VALUES ('124', '80', 'J7');  -- OK

SELECT * FROM TESTFK;

-- 외래키 제약조건에서 PARENT KEY 가 될 수 있는 컬럼은
-- PRIMARY KEY 또는 UNIQUE 제약조건이 설정된 컬럼만 참조컬럼이 될 수 있음.
CREATE TABLE NOPK (
    ID  CHAR(3),
    NAME VARCHAR2(10)
);

CREATE TABLE TESTFK2 (
    FID CHAR(3)  REFERENCES NOPK (ID), -- ERROR
    FNAME VARCHAR2(10)
);

CREATE TABLE TESTUN5 (
    ID CHAR(3) UNIQUE,
    NAME VARCHAR2(10)
);

CREATE TABLE TESTFK2 (
    FID CHAR(3)  REFERENCES TESTUN5 (ID), 
    FNAME VARCHAR2(10)
);


-- 복합키 설정 관련
-- 여러 개의 컬럼을 묶어서 UNIQUE 제약조건이나 PRIMARY KEY 제약조건을
-- 설정한 복합키를 참조할 경우
CREATE TABLE TEST_COMPLEX (
    ID  NUMBER,
    NAME VARCHAR2(10),
    UNIQUE (ID, NAME)
);

INSERT INTO TEST_COMPLEX VALUES (100, 'ORACLE');
INSERT INTO TEST_COMPLEX VALUES (NULL, NULL);
INSERT INTO TEST_COMPLEX VALUES (100, 'JAVA');
INSERT INTO TEST_COMPLEX VALUES (NULL, NULL);
INSERT INTO TEST_COMPLEX VALUES (NULL, 'JAVA');
INSERT INTO TEST_COMPLEX VALUES (NULL, 'JAVA');  -- ERROR
INSERT INTO TEST_COMPLEX VALUES (100, 'JAVA');  -- ERROR

SELECT * FROM TEST_COMPLEX;

-- 복합키를 참조키로 설정할 경우
CREATE TABLE TESTFK4 (
    ID  NUMBER,
    NAME VARCHAR2(10),
    PRICE NUMBER,
    FOREIGN KEY (ID, NAME) REFERENCES TEST_COMPLEX (ID, NAME)
);

-- 복합키로 설정된 참조컬럼은 따로 외래키 설정을 할 수 없음 : 에러
CREATE TABLE TESTFK5 (
    ID  NUMBER REFERENCES TEST_COMPLEX (ID),
    NAME VARCHAR2(10) REFERENCES TEST_COMPLEX (NAME),
    PRICE NUMBER--,
    --FOREIGN KEY (ID) REFERENCES TEST_COMPLEX (ID, NAME)
);  -- ERROR

-- 외래키가 설정된 컬럼에 값이 사용 중이면, 부모키는 절대 삭제할 수 없음.
DELETE FROM DEPARTMENT
WHERE DEPT_ID = '90';  -- 삭제 못 함 : 에러
-- EMPLOYEE 테이블에 DEPT_ID 컬럼에 '90'이 사용되고 있음 : CHILD RECORD

-- FOREIGN KEY 제약조건 설정시 삭제옵션을 추가할 수 있음 : DELETION OPTION
-- 기본은 자식레코드가 존재하면 부모키는 삭제 불가능임 (RESTRICTED)
-- ON DELETE SET NULL, ON DELETE CASCADE 

-- ON DELETE SET NULL 추가
-- 부모키가 삭제될 때 자식 레코드 값을 NULL 로 바꿈
CREATE TABLE PRODUCT_STATE (
    PSTATE  CHAR(1)  PRIMARY KEY,
    PCOMMENT  VARCHAR2(10)
);

INSERT INTO PRODUCT_STATE VALUES ('A', '최고급');
INSERT INTO PRODUCT_STATE VALUES ('B', '보통');
INSERT INTO PRODUCT_STATE VALUES ('C', '저급');

SELECT * FROM PRODUCT_STATE;

CREATE TABLE PRODUCT (
    PNAME  VARCHAR2(20)  PRIMARY KEY,
    PPRICE  NUMBER  CHECK (PPRICE > 0),
    PSTATE  CHAR(1) REFERENCES PRODUCT_STATE ON DELETE SET NULL
);

INSERT INTO PRODUCT VALUES ('갤럭시', 653000, 'A');
INSERT INTO PRODUCT VALUES ('G7', 740000, 'B');
INSERT INTO PRODUCT VALUES ('맥북', 2500000, 'C');

SELECT * FROM PRODUCT;

-- 삭제 테스트
DELETE FROM PRODUCT_STATE
WHERE PSTATE = 'A';

COMMIT;

SELECT * FROM PRODUCT;
SELECT * FROM PRODUCT_STATE;

-- ON DELETE CASCADE
-- 제공되는 부모키가 삭제되면, 제공값을 사용하는 자식 레코드도 함께 삭제됨
CREATE TABLE PRODUCT2 (
    PNAME VARCHAR2(20)  PRIMARY KEY,
    PPRICE  NUMBER,
    PSTATE  CHAR(1) REFERENCES PRODUCT_STATE (PSTATE) ON DELETE CASCADE
);

INSERT INTO PRODUCT2 VALUES ('멕북', 2500000, 'B');
INSERT INTO PRODUCT2 VALUES ('맥에어', 1250000, 'C');

SELECT * FROM PRODUCT2;

-- 부모키 삭제
DELETE FROM PRODUCT_STATE
WHERE PSTATE = 'B';

COMMIT;

-- 같이 삭제된 것 확인
SELECT * FROM PRODUCT_STATE;
SELECT * FROM PRODUCT2;


-- ***********************************************
-- 서브쿼리를 사용해서 새 테이블을 만들 수 있음

CREATE TABLE TABLE_SUBQUERY1
AS 
SELECT EMP_ID, EMP_NAME, SALARY, DEPT_NAME, JOB_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID);

SELECT * FROM TABLE_SUBQUERY1;

-- DESCRIBE 테이블명;
-- DESC 테이블명;
-- 테이블의 구조를 확인하는 명령어
DESC TABLE_SUBQUERY1;

-- 직원 테이블에서 90번 부서에 소속된 직원 정보만 따로 EMP_COPY90 테이블에 저장
CREATE TABLE EMP_COPY90
AS
SELECT * FROM EMPLOYEE
WHERE DEPT_ID = '90';

SELECT * FROM EMP_COPY90;

DESC EMP_COPY90;

-- 복사본 테이블 만들기
CREATE TABLE EMP_COPY
AS SELECT * FROM EMPLOYEE;

SELECT * FROM EMP_COPY;

DESC EMP_COPY;
-- 서브쿼리를 이용해서 기존 테이블을 복사할 경우,
-- 컬럼명, 자료형, NOT NULL 제약조건, 값은 그대로 복사됨.
-- 나머지 제약조건들은 복사되지 않음.

-- 제약조건 관련 데이터딕셔너리 확인
-- USER_CONSTRAINTS
SELECT * FROM USER_CONSTRAINTS;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP_COPY';

-- 실습 1
-- 사번, 이름, 급여, 직급명, 부서명, 근무지역명, 소속국가명 조회
-- 조회 결과를 EMP_LIST 테이블에 저장함
CREATE TABLE EMP_LIST
AS 
SELECT EMP_ID, EMP_NAME, SALARY, JOB_TITLE, 
        DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN LOCATION ON (LOC_ID = LOCATION_ID)
LEFT JOIN COUNTRY USING (COUNTRY_ID);

SELECT * FROM EMP_LIST;

-- 실습 2
-- EMPLOYEE 테이블에서 남자 직원의 정보만 조회해서
-- EMP_MAN 테이블에 저장함.
CREATE TABLE EMP_MAN
AS
SELECT * FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) IN ('1', '3');

SELECT * FROM EMP_MAN;

-- 실습 3
-- 여자 직원의 정보만 조회해서, EMP_FEMAIL 테이블에 저장함.
CREATE TABLE EMP_FEMAIL
AS
SELECT * FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) IN ('2', '4');

SELECT * FROM EMP_FEMAIL;

-- 실습 4
-- 부서별 직원 명단을 정리해서 PART_LIST 테이블에 저장함
-- DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID 로 컬럼 구성함
-- 컬럼에 주석 달기 : 부서명, 직급명, 사원명, 사번
CREATE TABLE PART_LIST
AS
SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID) 
ORDER BY DEPT_NAME;

SELECT * FROM PART_LIST;

COMMENT ON COLUMN PART_LIST.DEPT_NAME IS '부서명';
COMMENT ON COLUMN PART_LIST.JOB_TITLE IS '직급명';
COMMENT ON COLUMN PART_LIST.EMP_NAME IS '사원명';
COMMENT ON COLUMN PART_LIST.EMP_ID IS '사번';


-- 실습 : 제약조건이 설정된 테이블 만들기
-- 테이블명 : PHONEBOOK
-- 컬럼명 :  ID  CHAR(3) 기본키(저장이름 : PK_PBID)
--         PNAME      VARCHAR2(20)  널 사용못함.
--                                 (NN_PBNAME) 
--         PHONE      VARCHAR2(15)  널 사용못함
--                                 (NN_PBPHONE)
--                                 중복값 입력못함
--                                 (UN_PBPHONE)
--         ADDRESS    VARCHAR2(100) 기본값 지정함
--                                 '서울시 구로구'

-- NOT NULL을 제외하고, 모두 테이블 레벨에서 지정함.

CREATE TABLE PHONEBOOK (
       ID    CHAR(3),
       PNAME VARCHAR2(20) CONSTRAINT NN_PBNAME NOT NULL,
       PHONE VARCHAR2(15) CONSTRAINT NN_PBPHONE NOT NULL,
       ADDRESS VARCHAR2(100) DEFAULT '서울시 구로구',
       CONSTRAINT PK_PBID PRIMARY KEY (ID),
       CONSTRAINT UN_PBPHONE UNIQUE (PHONE)       
);

INSERT INTO PHONEBOOK
VALUES ('A01', '홍길동', '010-1234-5678', DEFAULT);

SELECT * FROM PHONEBOOK;



